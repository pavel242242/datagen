"""Postprocessing script generation (Path 2)."""

from pathlib import Path
from typing import Dict, List


class PostprocessorGenerator:
    """Generates postprocessing scripts (DuckDB SQL or Polars Python)."""

    def __init__(
        self,
        crunch_report: Dict,
        data_dir: Path,
        format: str = "duckdb",  # "duckdb" or "polars"
    ):
        self.crunch_report = crunch_report
        self.data_dir = data_dir
        self.format = format
        self.script_lines = []

    def can_postprocess(self) -> tuple[bool, str]:
        """Check if issues can be fixed via postprocessing.

        Returns:
            (can_postprocess, reason) tuple
        """
        issues = self.crunch_report.get("issues", [])

        # Count postprocess-fixable issues
        fixable_count = 0
        for issue in issues:
            if self._is_postprocess_fixable(issue):
                fixable_count += 1

        if fixable_count == 0:
            return False, "No postprocess-fixable issues found"

        return True, f"{fixable_count} issues can be fixed via postprocessing"

    def generate_script(self) -> str:
        """Generate postprocessing script.

        Returns:
            Script content as string
        """
        issues = self.crunch_report.get("issues", [])

        if self.format == "duckdb":
            self._init_duckdb_script()

            for issue in issues:
                if self._is_postprocess_fixable(issue):
                    self._generate_duckdb_fix(issue)

            self._finalize_duckdb_script()

        elif self.format == "polars":
            self._init_polars_script()

            for issue in issues:
                if self._is_postprocess_fixable(issue):
                    self._generate_polars_fix(issue)

            self._finalize_polars_script()

        return "\n".join(self.script_lines)

    def save_script(self, output_path: Path):
        """Save script to file."""
        script = self.generate_script()

        with open(output_path, "w") as f:
            f.write(script)

    def _is_postprocess_fixable(self, issue: Dict) -> bool:
        """Check if issue can be fixed via postprocessing."""
        finding = issue.get("finding", "").lower()
        category = issue.get("category", "")

        # Data quality issues that can be cleaned
        if "null" in finding or "outlier" in finding:
            return False  # These are more schema-level

        # Pricing, rounding, formatting issues
        if "price" in finding or "rounding" in finding or "format" in finding:
            return True

        return False

    def _init_duckdb_script(self):
        """Initialize DuckDB script header."""
        self.script_lines = [
            "-- Postprocessing script generated by DataPolisher",
            f"-- Source: {self.data_dir}",
            "-- Format: DuckDB SQL",
            "",
            "-- Load parquet files",
        ]

        # Load all tables
        for parquet_file in sorted(self.data_dir.glob("*.parquet")):
            table_name = parquet_file.stem
            self.script_lines.append(
                f"CREATE TABLE {table_name} AS SELECT * FROM read_parquet('{parquet_file}');"
            )

        self.script_lines.extend(["", "-- Apply transformations", ""])

    def _finalize_duckdb_script(self):
        """Finalize DuckDB script with export statements."""
        output_dir = self.data_dir.parent / "output_polished"

        self.script_lines.extend([
            "",
            "-- Export corrected tables",
            f"-- Output directory: {output_dir}",
            "",
        ])

        for parquet_file in sorted(self.data_dir.glob("*.parquet")):
            table_name = parquet_file.stem
            self.script_lines.append(
                f"COPY {table_name} TO '{output_dir}/{table_name}.parquet' (FORMAT PARQUET);"
            )

    def _generate_duckdb_fix(self, issue: Dict):
        """Generate DuckDB SQL fix for an issue."""
        # Placeholder - would implement based on issue type
        self.script_lines.append(f"-- TODO: Fix issue: {issue.get('finding', 'Unknown')}")

    def _init_polars_script(self):
        """Initialize Polars script header."""
        self.script_lines = [
            "# Postprocessing script generated by DataPolisher",
            f"# Source: {self.data_dir}",
            "# Format: Polars Python",
            "",
            "import polars as pl",
            "from pathlib import Path",
            "",
            "# Load parquet files",
        ]

        for parquet_file in sorted(self.data_dir.glob("*.parquet")):
            table_name = parquet_file.stem
            self.script_lines.append(
                f"{table_name} = pl.read_parquet('{parquet_file}')"
            )

        self.script_lines.extend(["", "# Apply transformations", ""])

    def _finalize_polars_script(self):
        """Finalize Polars script with export statements."""
        output_dir = self.data_dir.parent / "output_polished"

        self.script_lines.extend([
            "",
            "# Export corrected tables",
            f"output_dir = Path('{output_dir}')",
            "output_dir.mkdir(parents=True, exist_ok=True)",
            "",
        ])

        for parquet_file in sorted(self.data_dir.glob("*.parquet")):
            table_name = parquet_file.stem
            self.script_lines.append(
                f"{table_name}.write_parquet(output_dir / '{table_name}.parquet')"
            )

    def _generate_polars_fix(self, issue: Dict):
        """Generate Polars Python fix for an issue."""
        # Placeholder - would implement based on issue type
        self.script_lines.append(f"# TODO: Fix issue: {issue.get('finding', 'Unknown')}")
